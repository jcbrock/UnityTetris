//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
namespace AssemblyCSharp
{
		
		public class SceneInfo
		{
				public SceneInfo (StateUpdate stateUpdate)
				{
						StateUpdate = stateUpdate;
				}
				public StateUpdate StateUpdate;
		}
		//todo - rename?
		public class SceneRules
		{		
				public SceneRules ()
				{			
						
						
				}

				//For these member variables surfaced outside of class, only expose as read-only																
				private Shape mCurrentShape; //temp pbulic
				private Shape mPreviewShape;				
				public TetrisGrid mTetrisGrid = new TetrisGrid ();
				private ShapeFactory mFactory = new ShapeFactory ();				
				private static int debugId = 0; //Used to make debug print statements unique	
				//private bool mIsGameOver = false;
				private int mRulesetOption = -1;
				private List<AssemblyCSharp.ISceneRulesObserver> registeredObservers = new List<AssemblyCSharp.ISceneRulesObserver> ();

				public Shape GetCurrentShape ()
				{
						return mCurrentShape;
				}
				//public bool GetIsGameOver ()
				//{
				//		return mIsGameOver;
				//}
				public int GetCurrentScore ()
				{
						return mTetrisGrid.GetShapeCount ();
				}

				public void HandleTranslateRequest (UnityEngine.Vector3 movementVector)
				{		
						if (mCurrentShape == null)
								return;

						//move block
						mTetrisGrid.HandleTranslateRequest (mCurrentShape, movementVector);

						//Check for end game condition						
						if (mTetrisGrid.GetHighestRowContainingBlock () == 0) {								
								//mIsGameOver = true;		
								NotifyObservers (StateUpdate.GameEnded);
								return;
						}

						//Check if a shape was placed. If so, check for full rows, spawn new shape
						if (mTetrisGrid.WasShapeAddedToScene ()) {
								//Delete full rows
								foreach (int row in mTetrisGrid.GetFullRows ()) {										
										UnityEngine.Debug.Log ("Row " + row + " is full. Deleting now..." + ++debugId);
										mTetrisGrid.DeleteRow (row);
								}											

								mCurrentShape = mPreviewShape;																
								mCurrentShape.TranslateToInitialPlacement ();//todo - hmmmm
								mPreviewShape = mFactory.SpawnRandomizedTetrisShape (mRulesetOption);	
								NotifyObservers (StateUpdate.GeneratedNewShape);
						}

				}
				public void HandleRotateRequest ()
				{
						mTetrisGrid.HandleRotateRequest (mCurrentShape);
				}

				public void Initialize (int rowCount, int columnCount, int rulesetOption)
				{							
						mTetrisGrid.Initialize (rowCount, columnCount);
						mRulesetOption = rulesetOption;
						mCurrentShape = mFactory.SpawnRandomizedTetrisShape (mRulesetOption);
						mCurrentShape.TranslateToInitialPlacement ();										
						mPreviewShape = mFactory.SpawnRandomizedTetrisShape (mRulesetOption);																				
				}

				public void Cleanup ()
				{								
						if (mCurrentShape != null)
								mCurrentShape.DeleteShape ();
						if (mPreviewShape != null)
								mPreviewShape.DeleteShape ();													
						mCurrentShape = null;
						mPreviewShape = null;
						mTetrisGrid.Finalize2 ();
				}

				public void RegisterObserver (AssemblyCSharp.ISceneRulesObserver observer)
				{
						registeredObservers.Add (observer);
				}
				public void UnregisterObserver (AssemblyCSharp.ISceneRulesObserver observer)
				{
						registeredObservers.Remove (observer);
				}
				private void NotifyObservers (AssemblyCSharp.StateUpdate newState)
				{
						foreach (AssemblyCSharp.ISceneRulesObserver observer in registeredObservers) {
								observer.notify (new SceneInfo (newState));
						}		
				}		
		}
}