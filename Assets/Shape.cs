//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;

namespace AssemblyCSharp
{
		public class Shape
		{				
				private UnityEngine.GameObject compositeGameObject;

				//Hide default constructor
				private Shape ()
				{
				}

				public Shape (UnityEngine.GameObject compositeGameObject)
				{
						if (compositeGameObject == null)
								throw new ArgumentNullException ("A shape MUST contain a game object!");

						this.compositeGameObject = compositeGameObject;						
						enablePlayerControls ();
				}

				//cleans up UI of shape
				public void DeleteShape ()
				{
						UnityEngine.GameObject.Destroy (compositeGameObject);
				}

				public void Rotate90Degrees (bool clockwise)
				{

						UnityEngine.Debug.Log ("Trying to rotate!");
						UnityEngine.Vector3 rotation;		
						rotation = compositeGameObject.transform.eulerAngles;
						rotation.z = (rotation.z + (90 * (clockwise ? 1 : -1)));
						compositeGameObject.transform.eulerAngles = rotation;
				}

				//Can I get away with hiding any direct access to children?
				//i.e. I expose move functions / delete functions on shape which take care of any iteraction with Shape?

				public void translate (float x, float y, float z)
				{
						translateInWorldSpace (new UnityEngine.Vector3 (x, y, z));								
				}
				public void translate (UnityEngine.Vector3 vec)
				{
						translateInWorldSpace (vec);
				}
				private void translateInWorldSpace (UnityEngine.Vector3 vec)
				{
						compositeGameObject.transform.Translate (vec, UnityEngine.Space.World);
				}
				public void enablePlayerControls ()
				{
						setPlayerControls (true);
				}
				public void disablePlayerControls ()
				{
						setPlayerControls (false);
				}
				private void setPlayerControls (bool turnOn)
				{
						var playerControl = ((PlayerControl)compositeGameObject.GetComponent<PlayerControl> ());
						if (playerControl != null)
								playerControl.enabled = turnOn;
						else
								UnityEngine.Debug.Log ("No player control found!"); //todo - replace with an assert of some kind
				}
				
				//I suppose I could write my own detection here for colliding with another shape...
				public bool collides (Shape shape, float xDelta, float yDelta)
				{
						//TODO - clean this up... can't assume that Shape's GO is always a composite. Sometimes it is just a plain GO
						var foo = this.compositeGameObject.transform;
						var bar = shape.compositeGameObject.transform;
						//UnityEngine.Debug.Log (bar);
						if (xDelta == -1) {
								//UnityEngine.Debug.Log ("Moving Left...");
						}
						foreach (UnityEngine.Transform child1 in foo) {
								//UnityEngine.Debug.Log ("In outer loop");
								foreach (UnityEngine.Transform child2 in bar) {
										//	UnityEngine.Debug.Log ("In inner loop");
										//Move -delta AFTER x2
										if (xDelta == -1) {
												//UnityEngine.Debug.Log ("Child1 x,y: " + child1.position.x + ", " + child1.position.y);
												//UnityEngine.Debug.Log ("Child2 x,y: " + child2.position.x + ", " + child2.position.y);
												//UnityEngine.Debug.Log (((Mathf.Abs ((child1.position.x + xDelta) - child2.position.x) * 2)));
										}
										if (((UnityEngine.Mathf.Abs ((child1.position.x + xDelta) - child2.position.x) * 2) < ((((UnityEngine.BoxCollider)child1.collider).size.x + ((UnityEngine.BoxCollider)child2.collider).size.x) - .1) &&
												(UnityEngine.Mathf.Abs ((child1.position.y + yDelta) - child2.position.y) * 2) < ((((UnityEngine.BoxCollider)child1.collider).size.y + ((UnityEngine.BoxCollider)child2.collider).size.y) - .1))) {
												return true;			
										}
								}
						}
						return false;

				}

				//TODO - fix this up...... obviously wall should not be hard coded
				//Adding Collision stuff here since this is where the world object container is
				public bool isCollidingWithLeftWall ()
				{
						var foo = this.compositeGameObject.transform;
						foreach (UnityEngine.Transform child1 in foo) {
								if (((child1.position.x - (child1.renderer.bounds.size.x / 2.0)) - 1.0) < -.1) { //jitter (why it isnt 0)
										return true;	
								}
						}
						return false;
				}
		
				public bool isCollidingWithRightWall ()
				{
						var foo = this.compositeGameObject.transform;
						foreach (UnityEngine.Transform child1 in foo) {
								if (((child1.position.x + (child1.renderer.bounds.size.x / 2.0)) + 1.0) > 10.1) {
										return true;	
								}
						}
						return false;
				}
				public bool isCollidingWithBotWall ()
				{
						var foo = this.compositeGameObject.transform;
						foreach (UnityEngine.Transform child1 in foo) {
								if (((child1.position.y - (child1.renderer.bounds.size.y / 2.0) - 1.0)) < -25.1) {
										return true;	
								}
						}
						return false;
				}
		
				public bool isCollidingWithWall ()
				{
						var foo = this.compositeGameObject.transform;
						foreach (UnityEngine.Transform child1 in foo) {
								if (child1.position.x < 0 || child1.position.x > 10 || child1.position.y < -25) {
										return true;	
								}
						}
						return false;
				}
		}
}

