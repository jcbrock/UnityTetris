//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
namespace AssemblyCSharp
{
		public class TetrisGrid
		{
				//grid concept / collision detection, but no concept of current / preview shapes
				public TetrisGrid ()
				{
				}
						
				private System.Collections.ArrayList mListOfShapes; //used for updating the UI
				public TetrisBitArray mSceneGrid;  //temp public - for AI
				private int mPlacedShapeCount = 0;								
				private int mColumnCount;
				private int mRowCount;										
				private bool mWasShapeAddedToScene = false;
				private static int debugId = 0; //Used to make debug print statements unique					

				public bool WasShapeAddedToScene ()
				{
						return mWasShapeAddedToScene;
				}
				public int GetGridColumnCount ()
				{
						return mColumnCount;
				}
				public int GetGridRowCount ()
				{
						return mRowCount;
				}
				public int GetShapeCount ()
				{
						return mPlacedShapeCount;
				}
								
				//todo - figure out a better way
				public int GetHighestRowContainingBlock ()
				{
						int row = -1;
						for (int i = 0; i < mRowCount; ++i) {

								if (mSceneGrid.GetCountOfFilledBlocksInRow (i) != 0) {
										row = i;
										break;
								}
						}
						return row;
				}

				public void HandleTranslateRequest (Shape mCurrentShape, UnityEngine.Vector3 movementVector) //feed in shape into this scene
				{		
						mCurrentShape.ShadeSubBlock (0);
						mWasShapeAddedToScene = false;
						if (CheckCollisionWithLeftWall (mCurrentShape, movementVector) ||
								CheckCollisionWithRightWall (mCurrentShape, movementVector))
								return; //no action

						else if (CheckCollisionWithBotWall (mCurrentShape, movementVector) || DoAnyShapesCollideInScene (mCurrentShape, movementVector)) {								
								//m_CurrentShape.PlayCollisionAudio ();								
								mWasShapeAddedToScene = true;
								++mPlacedShapeCount;				
								mListOfShapes.Add (mCurrentShape);											
								AddCurrentShapeToSceneBitGrid (mCurrentShape, true);//??
								mSceneGrid.UpdateRowBytes ();																														
				
								mSceneGrid.PrintBitArray (); //debug print															
						} else
								mCurrentShape.translate (movementVector);						
				}
				public List<int> GetFullRows ()
				{
						return mSceneGrid.GetFullRows ();
				}

				//Delete row in UI and in the grid
				public void DeleteRow (int row)
				{
						DeleteRowInUI (row + 1); //need to -1 because row positions for the shapes are -1 to -25, not 0 to -24, gets converted to negative in func
						mSceneGrid.DeleteRow (row);
				}

				public void HandleRotateRequest (Shape shape)
				{
						UnityEngine.Vector3 movementVector = new UnityEngine.Vector3 (0, 0, 0);
						shape.Rotate ();
						if (CheckCollisionWithAnyWall (shape, movementVector) || DoAnyShapesCollideInScene (shape, movementVector)) {								
								shape.Rotate (true);								
						}
				}
		
				public void Initialize (int rowCount, int columnCount)
				{
						mRowCount = rowCount;	
						mColumnCount = columnCount;						
						mPlacedShapeCount = 0;
						mListOfShapes = new System.Collections.ArrayList ();
						mSceneGrid = new TetrisBitArray (mRowCount, mColumnCount);
				}
		
				public void Finalize2 ()
				{			
						foreach (Shape s in mListOfShapes) {
								s.DeleteShape ();
						}						
						mSceneGrid.ClearGrid ();
						mListOfShapes.Clear ();												
						mPlacedShapeCount = 0;
				}				
		
				private void AddCurrentShapeToSceneBitGrid (Shape shape, bool val)
				{		
						List<Coordinate> filledGridPositions = shape.GetCurrentGridPosition (); //todo - convert to an array of 4
						Coordinate[] foo = filledGridPositions.ToArray (); //todo - how to only make it 4 elements?
						foreach (Coordinate pos in filledGridPositions) {
								mSceneGrid [pos.row, pos.column] = val;
						}
				}
		
				private void DeleteRowInUI (int row)
				{
						//Note: Actual object destruction is always delayed until after the current Update loop, but will always be done before rendering.
						//https://docs.unity3d.com/Documentation/ScriptReference/Object.Destroy.html
			
						UnityEngine.Debug.Log ("(Row + " + (row - 1) + ") Deleting x = : " + row + " in the UI." + ++debugId);
						List<Shape> shapesToRemove = new List<Shape> ();
						foreach (Shape s in mListOfShapes) {								
								if (s.DeleteBlocksInRow (row * -1) == 0) {//TODO, fix all my -1 crap. I have to translate this to acutal game pos, which is negative
										shapesToRemove.Add (s); //can't modify list while I'm iterating through it, mark for delete
								}
						}
			
						foreach (Shape s in shapesToRemove) {
								UnityEngine.Debug.Log (s.Name + " has been completely destroyed.");
								mListOfShapes.Remove (s);
								s.DeleteShape ();
						}
			
						foreach (Shape s2 in mListOfShapes) {										
								s2.ShiftBlocksAboveDeletedRow (row * -1);										
						}
				}

				private bool DoAnyShapesCollideInScene (Shape shape, UnityEngine.Vector3 movementVector)
				{
						List<Coordinate> filledGridPositions = shape.GetCurrentGridPosition ();
						foreach (Coordinate pos in filledGridPositions) {
								if (mSceneGrid [pos.row + (int)movementVector.y, pos.column + (int)movementVector.x] == true)
										return true;
						}
						return false;
				}					
				private bool CheckCollisionWithLeftWall (Shape shape, UnityEngine.Vector3 movementVector)
				{
						List<Coordinate> filledGridPositions = shape.GetCurrentGridPosition ();
						foreach (Coordinate pos in filledGridPositions) {																											
								if ((pos.column + movementVector.x) < 0) {
										return true;
								}
						}
						return false;
				}
				private bool CheckCollisionWithRightWall (Shape shape, UnityEngine.Vector3 movementVector)
				{
						List<Coordinate> filledGridPositions = shape.GetCurrentGridPosition ();
						foreach (Coordinate pos in filledGridPositions) {
								if (pos.column + movementVector.x >= mColumnCount) {
										return true;
								}
						}
						return false;
				}
				private bool CheckCollisionWithBotWall (Shape shape, UnityEngine.Vector3 movementVector)
				{
						List<Coordinate> filledGridPositions = shape.GetCurrentGridPosition ();
						foreach (Coordinate pos in filledGridPositions) {
								if (Math.Abs (pos.row + movementVector.y) >= mRowCount)
										return true;
						}
						return false;
				}
				private bool CheckCollisionWithTopWall (Shape shape, UnityEngine.Vector3 movementVector)
				{
						List<Coordinate> filledGridPositions = shape.GetCurrentGridPosition ();
						foreach (Coordinate pos in filledGridPositions) {
								if (pos.row + movementVector.y > 0) {
										return true;
								}
						}
						return false;
				}
			
				
				private bool CheckCollisionWithAnyWall (Shape shape, UnityEngine.Vector3 movementVector)
				{
						if (CheckCollisionWithLeftWall (shape, movementVector) ||
								CheckCollisionWithRightWall (shape, movementVector) ||
								CheckCollisionWithBotWall (shape, movementVector)) {
								return true;	
			
						}
						return false;
				}			
		}
}

