//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1022
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. 
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.IO;
namespace AssemblyCSharp
{		
		//The SceneManager class is responsible for
		// - game state
		// - manipulating the current falling shape (translate, rotate, compute AI path)		
		public class SceneManager : UnityEngine.MonoBehaviour
		{
									

				//For these member variables surfaced outside of class, only expose as read-only												
				private List<AssemblyCSharp.ISceneObserver> registeredObservers = new List<AssemblyCSharp.ISceneObserver> ();
				private ShapeFactory mFactory; //todo - message passing to factor? or overkill? or not worth cuz I need to wait on it to return before I start again
				private Shape mCurrentShape;
				private Shape mPreviewShape;				
				private int mPlacedBlockCount = 0;				
				private System.Collections.ArrayList mListOfShapes = new System.Collections.ArrayList (); //used for updating the UI
				private static int mColumnCount = 8; //todo - handle game initialization better, more modular
				private static int mRowCount = 24;// todo - pass in from somewhere
				private TetrisBitArray mSceneGrid = new TetrisBitArray (mRowCount, mColumnCount);
				
				private Queue<UnityTetris.SceneRequestInfo> mRequestQueue = new Queue<UnityTetris.SceneRequestInfo> ();
				private GameState mCurrentGameState;				
				private int mRowTarget = 1;
				private int mColumnTarget = -1;
				private static int debugId = 0; //Used to make debug print statements unique

				//private AI aiManager = new AI ();
				
				public SceneManager ()
				{
							
				}		

				void Start ()
				{
						mFactory = new ShapeFactory ();				
				}

				public void SendSceneRequest (UnityTetris.SceneRequestInfo request)
				{
						mRequestQueue.Enqueue (request);
				}

				public void UpdateQueuedRequests ()
				{				
						if (mRequestQueue.Count != 0) {
								UnityTetris.SceneRequestInfo request = mRequestQueue.Dequeue (); //TODO - throttle?						
				
								switch (request.type) {
								case UnityTetris.SceneRequestInfo.Type.RotateShapeRequest:
										{
												if (mCurrentGameState == GameState.Running) {
														HandleRotateRequest (request);
												}
												break;
										}
								case UnityTetris.SceneRequestInfo.Type.TranslateShapeRequest:
										{
												if (mCurrentGameState == GameState.Running) {
														HandleTranslateRequest (request);
												}
												break;
										}
								case UnityTetris.SceneRequestInfo.Type.ChangeGameStateRequest:
										{
												HandleChangeGameStateRequest (request);
												break;
										}
								default:
										{
												UnityEngine.Debug.LogWarning ("No type sent on SceneRequestInfo request... this is probably bad!");
												break;
										}
								}
						}
				}
						
				private void HandleTranslateRequest (UnityTetris.SceneRequestInfo request)
				{
						//If this is true, a fresh game is starting
						if (mListOfShapes.Count == 0 && mCurrentShape == null && mPlacedBlockCount == 0) {
								//mCurrentShape = mFactory.SpawnRandomizedTetrisShape ();
								//mCurrentShape.TranslateToInitialPlacement ();										
								//mPreviewShape = mFactory.SpawnRandomizedTetrisShape ();																				
								mCurrentGameState = GameState.Running;
						}

						if (mCurrentGameState == GameState.Paused || mCurrentShape == null)
								return;							
						
						UnityEngine.Vector3 movementVector = request.translationData.movementVector;
						
						/*if (request.AIModeOn) {
								if (mRowTarget <= 0 && mColumnTarget >= 0) {
										List<Coordinate> rowCols = mCurrentShape.GetCurrentGridPosition ();																																	
										if (mColumnTarget < rowCols [0].column)
												movementVector.x = -1;
										if (mColumnTarget > rowCols [0].column)
												movementVector.x = 1;
								}				
						} else {
								mRowTarget = 1;
								mColumnTarget = -1;

						}*/

						//if (mCurrentShape.CheckCollisionWithBotWall (movementVector) || DoAnyShapesCollideInScene (movementVector)) {
						//m_CurrentShape.PlayCollisionAudio ();
						++mPlacedBlockCount;
								
						mListOfShapes.Add (mCurrentShape);											
						AddCurrentShapeToSceneBitGrid (true);
						mSceneGrid.UpdateRowBytes ();									
				
						//Handle game end condition
						//if (mCurrentShape.CheckCollisionWithTopWall (0, 0)) {
						UnityEngine.GameObject.Find ("background").audio.Play ();
						NotifyObservers (mPlacedBlockCount, GameState.Ended);
						//EndGame ();
						//todo - fix
						//	UnityTetris.SceneRequestInfo request2 = new UnityTetris.SceneRequestInfo ();
						//	request2.gameStateData.changeGameStateTo = AssemblyCSharp.ChangeGameState.EndGame;
						//HandleChangeGameStateRequest (request2);
						return;
						//}
												
						NotifyObservers (mPlacedBlockCount);

						mSceneGrid.PrintBitArray ();
				
						//Detect full rows and delete/shift
						List<int> fullRows = mSceneGrid.GetFullRows (); //it'll be ordered 0 to 24
				
						//Delete full rows in UI and in the grid
						foreach (int row in fullRows) {										
								UnityEngine.Debug.Log ("Row " + row + " is full. Deleting now..." + ++debugId);
								DeleteRowInUI (row + 1); //need to -1 because row positions for the shapes are -1 to -25, not 0 to -24, gets converted to negative in func
								mSceneGrid.DeleteRow (row);
						}
				
						//Switch to previewed Shape and generate a new one															
						mCurrentShape = mPreviewShape;																
						mCurrentShape.TranslateToInitialPlacement ();
						//mPreviewShape = mFactory.SpawnRandomizedTetrisShape ();																			
								
						//If AI is turned on, calculate the best move for this new shape
						/*if (request.AIModeOn) {
								AIPlacementEval bestMove = aiManager.GetBestMove (mCurrentShape, mSceneGrid);								
								if (bestMove != null) {
										mRowTarget = bestMove.row;
										mColumnTarget = bestMove.column;
										for (int rot = 0; rot < bestMove.numberOfRotations; ++rot) {
												mCurrentShape.Rotate ();
										}
										
										UnityEngine.Debug.Log (++debugId + "score: " + bestMove.score + " rowTarget: " + bestMove.row + " columnTarget: " + bestMove.column + " rotation: " + bestMove.numberOfRotations);
								}
						}*/
						//myB.PrintBitArray ();
				
						//} //else if (!mCurrentShape.CheckCollisionWithLeftWall (movementVector) &&
						//		!mCurrentShape.CheckCollisionWithRightWall (movementVector)) {										
						//		mCurrentShape.translate (movementVector);
						//}
				}
				private void HandleRotateRequest (UnityTetris.SceneRequestInfo request)
				{
						//TODO - someday move rotate out of shape...
						mCurrentShape.Rotate ();
				}
				private void HandleChangeGameStateRequest (UnityTetris.SceneRequestInfo request)
				{
						/*switch (request.gameStateData.changeGameStateTo) {
						case AssemblyCSharp.ChangeGameState.ClearGame:
								{
										foreach (Shape s in mListOfShapes) {
												s.DeleteShape ();
										}
										if (mCurrentShape != null)
												mCurrentShape.DeleteShape ();
										if (mPreviewShape != null)
												mPreviewShape.DeleteShape ();
										mSceneGrid.ClearGrid ();
										mListOfShapes.Clear ();						
										mCurrentShape = null;
										mPlacedBlockCount = 0;
										break;
								}
						case AssemblyCSharp.ChangeGameState.PauseGame:
								{										
										mCurrentGameState = GameState.Paused;
										break;
								}
						case AssemblyCSharp.ChangeGameState.ResumeGame:
								{										
										mCurrentGameState = GameState.Running;
										break;
								}
						/*case AssemblyCSharp.ChangeGameState.StartGame:
								{
										mCurrentShape = mFactory.SpawnRandomizedTetrisShape ();
										mCurrentShape.TranslateToInitialPlacement ();										
										mPreviewShape = mFactory.SpawnRandomizedTetrisShape ();																				
										mCurrentGameState = GameState.Running;
										break;
								}
						case AssemblyCSharp.ChangeGameState.EndGame:
								{		
										foreach (Shape s in mListOfShapes) {
												s.DeleteShape ();
										}
										if (mCurrentShape != null)
												mCurrentShape.DeleteShape ();
										if (mPreviewShape != null)
												mPreviewShape.DeleteShape ();
										mSceneGrid.ClearGrid ();
										mListOfShapes.Clear ();						
										mCurrentShape = null;
										mPlacedBlockCount = 0;										
										mCurrentGameState = GameState.Paused;
										break;													
								}
						}	*/			
				}
						
				public void AddCurrentShapeToSceneBitGrid (bool val)
				{		
						List<Coordinate> filledGridPositions = mCurrentShape.GetCurrentGridPosition (); //todo - convert to an array of 4
						Coordinate[] foo = filledGridPositions.ToArray (); //todo - how to only make it 4 elements?
						foreach (Coordinate pos in filledGridPositions) {
								mSceneGrid [pos.row, pos.column] = val;
						}
				}

				public bool DoAnyShapesCollideInScene (UnityEngine.Vector3 movementVector)
				{
						List<Coordinate> filledGridPositions = mCurrentShape.GetCurrentGridPosition ();
						foreach (Coordinate pos in filledGridPositions) {
								if (mSceneGrid [pos.row + (int)movementVector.y, pos.column + (int)movementVector.x] == true)
										return true;
						}
						return false;
				}
		
				private void DeleteRowInUI (int row)
				{
						//Note: Actual object destruction is always delayed until after the current Update loop, but will always be done before rendering.
						//https://docs.unity3d.com/Documentation/ScriptReference/Object.Destroy.html
									
						UnityEngine.Debug.Log ("(Row + " + (row - 1) + ") Deleting x = : " + row + " in the UI." + ++debugId);
						List<Shape> shapesToRemove = new List<Shape> ();
						foreach (Shape s in mListOfShapes) {								
								if (s.DeleteBlocksInRow (row * -1) == 0) {//TODO, fix all my -1 crap. I have to translate this to acutal game pos, which is negative
										shapesToRemove.Add (s); //can't modify list while I'm iterating through it, mark for delete
								}
						}
			
						foreach (Shape s in shapesToRemove) {
								UnityEngine.Debug.Log (s.Name + " has been completely destroyed.");
								mListOfShapes.Remove (s);
								s.DeleteShape ();
						}
			
						foreach (Shape s2 in mListOfShapes) {										
								s2.ShiftBlocksAboveDeletedRow (row * -1);										
						}
				}
		

				public void RegisterObserver (AssemblyCSharp.ISceneObserver observer)
				{
						registeredObservers.Add (observer);
				}
				public void UnregisterObserver (AssemblyCSharp.ISceneObserver observer)
				{
						registeredObservers.Remove (observer);
				}
				private void NotifyObservers (int currentPlacedShapeCount)
				{
						NotifyObservers (currentPlacedShapeCount, GameState.None);	
				}
				private void NotifyObservers (int currentPlacedShapeCount, GameState gameState)
				{
						foreach (AssemblyCSharp.ISceneObserver observer in registeredObservers) {
								observer.notify (new GameInfoPacket (currentPlacedShapeCount, gameState));
						}		
				}	
		}
}
