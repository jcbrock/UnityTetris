//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
namespace AssemblyCSharp
{
	//TetrisBitArray is responsible for
	// - providing convient way to access bit array (allowing (x,y) syntax)
	// - checking which rows are full
	// - deleting full rows
	// - updating internal bit array
	public class TetrisBitArray
	{
		private BitArray m_BitArray;
		public byte[] m_RowBytes;
		private int m_RowCount;
		private int m_ColumnCount;
		private TetrisBitArray ()
		{
		}
		public TetrisBitArray (int rowCount, int columnCount)
		{
			m_BitArray = new BitArray (rowCount * columnCount);
			m_RowCount = rowCount;
			m_ColumnCount = columnCount;
			m_RowBytes = new byte[rowCount];//assuming 1 row = 8 bytes 
		}
		
		public bool this [int rowIndex, int columnIndex] {
			get {
				rowIndex = Math.Abs (rowIndex);
				if (rowIndex < 0 || rowIndex >= m_RowCount)
					throw new ArgumentOutOfRangeException ("rowIndex");
				
				if (columnIndex < 0 || columnIndex >= m_ColumnCount)
					throw new ArgumentOutOfRangeException ("columnIndex");
				
				int pos = rowIndex * m_ColumnCount + columnIndex;
				return m_BitArray [pos];
			}
			set {
				rowIndex = Math.Abs (rowIndex);
				if (rowIndex < 0 || rowIndex >= m_RowCount)
					throw new ArgumentOutOfRangeException ("rowIndex");
				
				if (columnIndex < 0 || columnIndex >= m_ColumnCount)
					throw new ArgumentOutOfRangeException ("columnIndex");
				
				int pos = rowIndex * m_ColumnCount + columnIndex;
				
				m_BitArray [pos] = value;
			}
		}
		
		public List<int> GetFullRows ()
		{
			List<int> fullRows = new List<int> ();
			
			//Check for full rows using bit masks
			for (int i = 0; i < m_RowCount; ++i) {
				TetrisBitArray fullRowMask = new TetrisBitArray (m_RowCount, m_ColumnCount);
				fullRowMask.m_RowBytes [i] = Byte.MaxValue;
				fullRowMask.UpdateBitArrayBasedOnRowBytes ();				
				BitArray clone = (BitArray)this.m_BitArray.Clone (); //need to close because AND will modify left-hand arg
				
				if (fullRowMask.Equals (clone.And (fullRowMask.m_BitArray)))
					fullRows.Add (i);
			}
			
			return fullRows;
		}
		
		public bool Equals (BitArray b)
		{
			if (this.m_BitArray.Count != b.Count)
				throw new ArgumentException ("Can't compare BitArrays of different length");
			
			//Not a good way to compare equality of bit arrays in C#
			//At least this does 32 times less compares than comparing bit by
			int[] ints1 = ConvertToInts (this.m_BitArray);
			int[] ints2 = ConvertToInts (b);
			for (int i = 0; i < ints1.Length; ++i)
				if (ints1 [i] != ints2 [i])
					return false;
			
			return true;
		}
		
		private int[] ConvertToInts (BitArray bits)
		{
			int arraySize = Convert.ToInt32 (Math.Ceiling ((double)(bits.Count / 32)));
			
			//TODO - remove debug check
			if (bits.Count != 192) {
				UnityEngine.Debug.LogWarning ("Grid length not 192");
			}
			
			int[] ints = new int[arraySize];
			bits.CopyTo (ints, 0);
			return ints;
		}
		
		public void UpdateRowBytes ()
		{
			if (m_BitArray.Count != 192) {
				throw new ArgumentException ("# of bits is wrong for row bytes");
			}
			//byte[] bytes = new byte[24];
			m_BitArray.CopyTo (m_RowBytes, 0);
			//return bytes;
		}
		public void UpdateBitArrayBasedOnRowBytes ()
		{
			m_BitArray = new BitArray (m_RowBytes);
		}
		
		
		public void PrintBitArray ()
		{
			string output = string.Empty;
			
			for (int i = 0; i < m_RowCount; ++i) {
				string space = " ";
				if (i < 10)
					space = "  ";
				
				output += Environment.NewLine + "Row " + i + space;
				for (int j = 0; j < m_ColumnCount; ++j) {
					output += Convert.ToInt32 (this [i, j]) + " ";								
				}								
			}
			UnityEngine.Debug.Log (output);
		}
		
		static int foo = 0;
		public void DeleteRow (int row)
		{
			row = Math.Abs (row);
			
			//TODO - clean up all extra bit arrays and crap.
			
			//row 0 = top row
			//row 23 = bot row
			BitArray x = (BitArray)this.m_BitArray.Clone ();
			BitArray yBot = new BitArray (m_ColumnCount * m_RowCount);
			for (int i = ((row + 1) * m_ColumnCount); i < (m_RowCount * m_ColumnCount); ++i) { //yBot = everything below full row, hence -1
				yBot [i] = true; //-192 > -192
				//-184 > -192, -185 > -192, -186 > 192
			}
			
			//Debug - print stuff
			TetrisBitArray p2 = new TetrisBitArray (m_RowCount, m_ColumnCount);
			/*p2.m_data = yBot;
			++foo;
			UnityEngine.Debug.Log ("yBot" + foo);
			p2.PrintBitArray ();*/
			++foo;
			UnityEngine.Debug.Log ("Before shift" + foo);
			this.PrintBitArray ();
			
			//shift - CAN'T do via mask because I don't have one consecutive array of bits in C#.
			//They are split up across ints, which makes shifting a bitch - I still have to copy between ints
			//(last part of int to first part of next int...), so it is easier just to use byte array.
			for (int i = m_RowCount -1; i > 0; --i) {
				this.m_RowBytes [i] = this.m_RowBytes [i - 1];
			}
			this.m_RowBytes [0] = 0;
			this.UpdateBitArrayBasedOnRowBytes ();
			
			//Debug print stuff
			++foo;
			UnityEngine.Debug.Log ("After shift" + foo);
			this.PrintBitArray ();
			
			BitArray yTop = new BitArray (m_ColumnCount * m_RowCount);
			for (int i = (((row +1) * m_ColumnCount)-1); i >= 0; --i) { //includes the full row, hence the -1 (+1 is for 0-191, not 1-192)
				yTop [i] = true;
			}
			/*++foo;
			UnityEngine.Debug.Log ("After yTop construction" + foo);

			//Debug - print
			MyBitArray p = new MyBitArray (height, m_RowWidth);
			p.m_data = yTop;
			++foo;
			UnityEngine.Debug.Log ("yTop" + foo);
			p.PrintBitArray ();*/
			++foo;
			UnityEngine.Debug.Log ("Answer" + foo);
			
			TetrisBitArray ans = new TetrisBitArray (m_RowCount, m_ColumnCount);
			ans.m_BitArray = (x.And (yBot)).Or (this.m_BitArray.And (yTop)); //Take bottom or original grid, add it to the top of the shifted down grid
			ans.PrintBitArray ();
			this.m_BitArray = ans.m_BitArray;
		}	
	}
}

